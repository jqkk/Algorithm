## 함수를 정의하는 방법

1. 함수 선언문으로 정의하는 방법

```javaScript
  function square(x) {return x*x}
```

2. 함수 리터럴로 정의하는 방법

```javaScript
  const square = function(x) {return x*x; };
```

3. Function 생성자로 정의하는 방법

```javaScript
  const square = new Function('x','return x*x')
```

4. 화살표 함수 표현식으로 정의하는 방법

```javaScript
  const square = x => x*x;
```

## 중첩 함수

특정 함수의 내부에 선언된 함수를 가리켜 그 함수의 중첩 함수라고 한다. C나 Java 등에서는 중첩 함수를 사용할 수 없지만 JS에서는 중첩 함수를 사용할 수 있다. 그러나 외부함수의 최상위 레벨에만 중첩 함수를 작성할 수 있다.(**함수 안의 if 문과 while 문 등의 문장 블록 안에는 중첩 함수를 작성할 수 없다**)

## 함수를 호출하는 방법

1. 함수 호출

```javaScript
  const s = square(5)
```

2. 메서드 호출

```javaScript
  obj.m = function() { ... }
  obj.m()
```

3. 생성자 호출

```javaScript
  const obj = new Object();
```

4. call, apply를 사용한 간접 호출

## 자바스크립트 엔진

실행 가능한 코드 -> 평가 -> 실행 문맥

## 실행 문맥

- 실행 가능한 코드가 실제로 실행되고 관리되는 영역
- 컴포넌트 여러 개가 나누어 관리
  - 렉시컬 환경 컴포넌트 & 변수 환경 컴포넌트 : 렉시컬 환경 타입의 컴포넌트
  - 디스 바인딩 컴포넌트 : 그 함수를 호출한 객체의 참조가 저장되는 곳 -> this

# 렉시컬 환경 컴포넌트

- 자바스크립트 엔진이 자바스크립트 코드를 실행하기 위해서 자원을 모아둔 곳
- 식별자와 결과값 저장(키와 값의 쌍으로 바인드)
  - 환경 레코드 : 식별자를 기록하고 실행하는 영역(자바스크립트 엔진은 식별자와 결과값을 바인드해서 환경 레코드에 기록한다)
  - 외부 렉시컬 환경 참조 : 함수를 둘러싸고 있는 코드가 속한 렉시컬 환경 컴포넌트의 참조가 저장(중첩 함수 관련)

## 환경 레코드

- 식별자와 그 실별자가 가리키는 값의 묶음이 실제로 저장되는 영역
  - 선언적 환경 레코드 : 함수, 변수, catch 문의 식별자와 실행 결과가 저장되는 영역
  - 객체 환경 레코드 : 실행 문맥 외부에 별도로 저장된 객체의 참조에서 데이터를 읽거나 씀(키와 값의 쌍을 복사해 오는 것이 아닌 그 객체 전체 참조를 가져와 객체 환경 레코드의 bindObject 프로퍼티에 바인딩)

## this 값

1. 최상위 레벨 코드의 this <br>
   최상위 레벨 코드의 this는 전역 객체를 기리킨다. 실행 문맥이 초기화될 때 그 안의 디스 바인딩 컴포넌트가 전역 환경을 가리키도록 초기화되기 때문이다.

2. 이벤트 처리기 안에 있는 this <br>
   이벤트 처리기 안에 있는 this는 이벤트가 발생한 요소 객체(이벤트 처리기가 등록된 객체)를 가리킨다.

3. 생성자 함수 안에 있는 this <br>
   사용자가 정의한 생성자 함수 안에 있는 this는 그 생성자로 생성한 객체를 가리킨다.

4. 생성자의 prototype 메서드 안에 있는 this <br>
   생성자의 prototype 메서드 안에 있는 this는 그 생성자로 생성한 객체를 가리킨다.

5. 직접 호출한 함수 안에 있는 this <br>
   함수 최상위 레벨의 코드에서 호출하면 함수 안에 있는 this가 전역 객체를 가리킨다. 함수 앞에 어떤 객체를 붙여서 호출하면 디스 바인딩 컴포너트가 그 객체를 가리킨다.

6. apply와 call 메서드로 호출한 함수 안에 있는 this <br>
   함수 객체의 apply와 call 메서드를 사용하면 함수를 호출할 때 this가 가리키는 객체를 바꿀 수 있다. 즉, 그 함수 객체가 실행되는 실행 문맥의 디스 바인딩 컴포넌트가 가리키는 객체를 명시적으로 설정할 수 있다.

## 클로저를 이해하기 위한 핵심 사항

- 외부 함수를 호출하면 그 함수의 렉시컬 환경 컴포너트가 생성된다. 그리고 그 안에 중첩된 중첩 함수의 함수 객체를 생성해서 반환한다. 그 결과 외부 함수의 렉시컬 환경 컴포넌트를 참조하는 중첩 함수가 정의한 클로저가 생성된다. 즉, 외부 함수는 클로저를 생성하는 팩토리 함수라고 할 수 있다.
- 외부 함수가 속한 렉시컬 환경 컴포넌트는 클로저 내부 상태 자체이다. 외부 함수가 호출될 때마다 새로 생성된다.
- 중첩 함수의 함수 객체가 있는 한 외부 함수가 속한 렉시컬 환경 컴포넌트는 지워지지 않는다. 외부 함수의 함수 객체가 사라져도 지워지지 않는다.
- 클로저 내부 상태는 외부로부터 은폐되어 있으며 중첩 함수 안에서만 읽거나 쓸 수 있다.

## 이름 공간

변수 이름과 함수 이름을 한곳에 모아 두어 이름 충돌을 미리 방지하고, 변수와 함수를 쉽게 가져다 쓸 수 있게 만든 메커니즘

## 객체로서의 함수

- 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다
- 함수는 함수의 인수로 사용할 수 있다
- 함수는 함수의 반환값으로 사용할 수 있다.
- 함수는 프로퍼티와 메서드를 가질 수 있다.
- 함수는 이름 없는 리터럴로 표현할 수 있다.(익명 함수)
- 함수는 동적으로 생성할 수 있다.

-> **일급함수**

## 함수의 프로퍼티

- caller : 현재 실행중인 함수를 호출한 함수
- length : 함수의 인자 개수
- name : 함수를 표시할 때 사용하는 이름
- prototype : 프로토타입 객체의 참조

## Function.prototype의 프로퍼티

- apply() : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 배열 객체다
- bind : 선택한 this와 인수를 적용한 새로운 함수를 반환한다.
- call : 선택한 this와 인수를 사용하여 함수를 호출한다. 인수는 쉼표로 구분한 값이다.
- constructor : Function 생성자의 참조
- toString() : 함수의 소스 코드를 문자열로 만들어 반환한다.

## 고차 함수

함수를 인수로 받는 함수 또는 함수를 반환하는 함수를 말한다

## 콜백 함수

다른 함수에 인수로 넘겨지는 함수

## 함수 리터럴과 화살표 함수의 차이점

1. this의 값이 함수를 정의할 때 결정된다 <br>
   함수 리터럴로 정의한 함수의 this 값은 함수를 호출 할 때 결정된다. 그러나 화살표 함수의 this 값은 함수를 정의할 때 결정된다. 즉, 화살표 함수 바깥의 this 값이 화살표 함수의 this 값이 된다.

2. arguments 변수가 없다

3. 생성자로 사용할 수 없다

4. yield 키워드를 사용할 수 없다

## 제너레이터

- 반복 가능한 이터레이터를 값으로 반환한다
- 작업의 일시 정지와 재시작이 가능하며 자신의 상태를 관리한다
